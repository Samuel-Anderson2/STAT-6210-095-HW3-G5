---
title: "HW3 - G5"
author: "Sam Anderson, Cooper Niebuhr, Janset Aksoy"
Date: "2025-11-10"
output: html_document
---
GPT Links:
Sam Anderson: https://chatgpt.com/share/6912471f-dfd4-8004-8334-f795c8e4a471

# 1.- Refactor prior HW2 tasks into functions

### 1.1
```{r}
label_by_median <- function(x) {
  if (!is.numeric(x)) {
    stop("Error: Input must be a numeric vector.")
  }
  
  med <- median(x, na.rm = TRUE)
  
  label <- ifelse(
    is.na(x), NA,
    ifelse(x >= med, "at_or_above_median", "below_median")
  )
  
  data.frame(value = x, label = label, stringsAsFactors = FALSE)
}
```

### 1.2
```{r}
even_until <- function(n, k) {
  evens <- c()
  for (i in 1:n) {
    if (i %% 2 == 1) next 
    if (i %% k == 0) break        
    evens <- c(evens, i)
  }
  return(evens)
}
```

### 1.3
```{r}
sum_until <- function(thresh, rng = runif) {
  total <- 0
  draws <- c()
  
  while (total <= thresh) {
    x <- rng(1)             
    total <- total + x      
    draws <- c(draws, x)
  }
  
  return(list(total = total, draws = draws))
}
```

### 1.4 
```{r}
estimate_pi <- function(n) {
  inside <- 0
  for (i in 1:n) {
    x <- runif(1)
    y <- runif(1)
    if (x^2 + y^2 <= 1) {
      inside <- inside + 1
    }
  }
  pi_hat <- 4 * inside / n
  return(list(inside = inside, n = n, pi_hat = pi_hat))
}
```

### 1.5 
```{r}
rw_sim <- function(n = 1000, boundary = 10) {
  S <- numeric(n)
  
  for (t in 2:n) {
    step <- sample(c(-1, 1), 1) 
    S[t] <- S[t - 1] + step
    if (abs(S[t]) > boundary) {
      return(list(S = S[1:t], stop_time = t))
    }
  }
  
  return(list(S = S, stop_time = NA))
}
```

```{r}
x<- c(3, 5, 7, 8, 9, NA, 2, 3)
label_by_median(x)
even_until(10, 8)
sum_until(10)
estimate_pi(x)
rw_sim(100, 5)
```
# 2. - Alternative Functions

### 2.1 - Threshold Labeling with Custom Statistic
```{r}

label_by_stat <- function(z, stat = median) {
  # 1. Compute the threshold by applying the stat function to the vector z
  threshold <- stat(z)
  
  # 2. Return a logical vector comparing each element of z to the threshold
  return(z >= threshold)
}


# --- 1. Set up sample data ---
# We'll use a vector that is slightly skewed
# so that mean and median give different results.
z_demo <- c(10, 2, 5, 20, 15, 30, 8, 9, 100, 1)

# Sorted data: 1, 2, 5, 8, 9, 10, 15, 20, 30, 100
print(paste("Sample data (z_demo):", toString(z_demo)))


# --- 2. Demonstration with default (stat = median) ---
# The default stat is median.
# Median of z_demo is (9 + 10) / 2 = 9.5
print(label_by_stat(z_demo))
# Expected: z_demo >= 9.5
# [1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE


# --- 3. Demonstration with stat = mean ---
# The mean of z_demo is (10+2+5+20+15+30+8+9+100+1) / 10 = 20.
print(label_by_stat(z_demo, stat = mean))
# Expected: z_demo >= 20
# [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE


# --- 4. Demonstration with custom 75th percentile function ---

# First, define the custom function as requested.
# We use quantile() and set names = FALSE to get a clean numeric value.
q75 <- function(x) {
  quantile(x, probs = 0.75, names = FALSE)
}

# The 75th percentile of z_demo is 16.25
print(label_by_stat(z_demo, stat = q75))
# Expected: z_demo >= 16.25
# [1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE

```

### 2.2 - Generalized Accumulator with Stop Rule

```{r}

accumulate_until <- function(step_fun, stop_rule) {
  total <- 0
  iters <- 0
  trace <- c() 
  
  # Loop *while* the stop rule is NOT met (is FALSE)
  # We check the rule before adding the next increment.
  while (!stop_rule(total)) {
    increment <- step_fun()
    
    total <- total + increment
    
    trace <- c(trace, total)
    
    iters <- iters + 1
  }
  
  return(list(
    total = total,
    iters = iters,
    trace = trace
  ))
}

# --- 1. Set a seed for reproducible results ---
set.seed(42)

# --- 2. Define the step and stop functions ---

# Step function: Draw one random number from a uniform distribution (0 to 1)
uniform_step <- function() {
  runif(1)
}

# Stop rule: Stop when the total is greater than or equal to 6
stop_at_6 <- function(total) {
  return(total >= 6)
}

# --- 3. Run the simulation ---
simulation_result <- accumulate_until(
  step_fun = uniform_step,
  stop_rule = stop_at_6
)

# --- 4. Print the results ---
print("--- Uniform Sum Simulation (Threshold 6) ---")
print(simulation_result)

```

###2.3 - Random Walk with Reflecting Boundaries

```{r}

library(ggplot2)
library(tidyr) 

simulate_bacteria <- function(N = 20, T_max = 150, a = 0, b = 2, move = FALSE,
                              food_radius = 3, init_range = 9) {
  
  # 1. Initialize data structures
  traj <- array(NA, 
                dim = c(T_max + 1, N, 2), 
                dimnames = list(paste0("t", 0:T_max), 
                                paste0("bact", 1:N), 
                                c("x", "y")))
  
  # 2. Set initial positions (t=0)
  traj[1, , "x"] <- runif(N, -init_range, init_range)
  traj[1, , "y"] <- runif(N, -init_range, init_range)
  
  # 3. is_active tracks which bacteria are still moving
  is_active <- rep(TRUE, N)
  
  # --- 4. Run Simulation Loop ---
  for (t in 1:T_max) {
    active_indices <- which(is_active)
    
    if (length(active_indices) == 0) {
      for (t_fill in (t + 1):(T_max + 1)) {
        traj[t_fill, , ] <- traj[t, , ]
      }
      break 
    }
    
    current_x <- traj[t, active_indices, "x"]
    current_y <- traj[t, active_indices, "y"]
    
    n_active <- length(active_indices)
    S_t <- runif(n_active, a, b)
    delta_t <- runif(n_active, 0, 2 * pi)
    
    new_x <- current_x + S_t * cos(delta_t)
    new_y <- current_y + S_t * sin(delta_t)
    
    traj[t + 1, active_indices, "x"] <- new_x
    traj[t + 1, active_indices, "y"] <- new_y
    

    inactive_indices <- which(!is_active)
    if (length(inactive_indices) > 0) {
      traj[t + 1, inactive_indices, "x"] <- traj[t, inactive_indices, "x"]
      traj[t + 1, inactive_indices, "y"] <- traj[t, inactive_indices, "y"]
    }
    
    # --- 5. Update Active Status (The Stop Rule) ---
    if (move == FALSE) {
      dist_from_center <- sqrt(new_x^2 + new_y^2)
      
      found_food <- (dist_from_center <= food_radius)
      
      global_indices_to_stop <- active_indices[found_food]
      
      is_active[global_indices_to_stop] <- FALSE
    }
  }
  
  # 6. Prepare and return results
  final_pos <- traj[T_max + 1, , ]
  
  return(list(
    trajectories = traj,
    final_positions = final_pos
  ))
}

# --- 1. Run the simulation (with default move=FALSE) ---
set.seed(123) # For reproducible results
sim_results <- simulate_bacteria(N = 20, T_max = 150, move = FALSE)

# --- 2. Prepare data for ggplot ---

# Convert the 3D 'trajectories' array into a 2D data frame
traj_array <- sim_results$trajectories
traj_df <- as.data.frame.table(traj_array, responseName = "value")
colnames(traj_df) <- c("time_step", "bacterium", "coord", "value")

# Pivot to get x and y in separate columns
plot_df <- pivot_wider(traj_df, 
                       names_from = coord, 
                       values_from = value)

# Convert time from a factor (e.g., "t0") to a number for plotting order
plot_df$time_num <- as.numeric(gsub("t", "", plot_df$time_step))

# --- 3. Create the food circle data ---
food_circle <- data.frame(
  angle = seq(0, 2 * pi, length.out = 100)
)
food_circle$x <- 3 * cos(food_circle$angle)
food_circle$y <- 3 * sin(food_circle$angle)

# --- 4. Create the plot ---
ggplot(plot_df, aes(x = x, y = y, color = bacterium)) +
  
  # Add the food circle (in blue)
  geom_path(data = food_circle, 
            aes(x = x, y = y), 
            color = "blue", 
            size = 1.2, 
            inherit.aes = FALSE) +
  
  # Add the bacteria trajectories
  geom_path(aes(group = bacterium), alpha = 0.6) +
  
  # Add final positions (as black-outlined points)
  geom_point(data = as.data.frame(sim_results$final_positions),
             aes(x = x, y = y), 
             color = "black", 
             shape = 21, # Circle with outline
             fill = "white",
             size = 2, 
             stroke = 1.1,
             inherit.aes = FALSE) +
  
  # Make the plot square
  coord_fixed(xlim = c(-15, 15), ylim = c(-15, 15)) +
  
  labs(
    title = "Bacteria Run-and-Tumble (Stop on Entry)",
    x = "X Position",
    y = "Y Position",
    caption = "Each bacterium stops at its first position inside the blue food circle."
  ) +
  theme_minimal() +
  
  # Hide the legend (it's too crowded with 20 colors)
  theme(legend.position = "none")

```

### 3

```{r, echo=FALSE}
library(tidyverse)

#------------------------------------------------------------
# 1. fit_models_dim()
#------------------------------------------------------------
fit_models_dim <- function(X, y, k, m) {
  vars <- colnames(X)
  combos <- combn(vars, k, simplify = FALSE)

  if (length(combos) > m) {
    combos <- combos[1:m]
  }

  results <- map_df(combos, function(vs) {
    df <- data.frame(y = y, X[, vs, drop = FALSE])
    fit <- glm(y ~ ., data = df, family = binomial())

    tibble(
      vars  = list(vs),
      aic   = AIC(fit),
      coef  = list(coef(fit)),
      pvals = list(summary(fit)$coefficients[,4])
    )
  })

  return(results)
}

#------------------------------------------------------------
# 2. select_best()
#------------------------------------------------------------
select_best <- function(models_df, alpha = 0.5) {
  stopifnot(alpha > 0, alpha <= 1)
  n_keep <- ceiling(nrow(models_df) * alpha)

  models_df %>%
    arrange(aic) %>%
    slice(1:n_keep)
}

#------------------------------------------------------------
# 3. grow_from()
#------------------------------------------------------------
grow_from <- function(best_df, all_vars, k_next, m) {
  new_models <- list()

  for (i in seq_len(nrow(best_df))) {
    base_vars <- unlist(best_df$vars[[i]])
    remaining <- setdiff(all_vars, base_vars)

    for (v in remaining) {
      new_set <- sort(c(base_vars, v))
      new_models <- append(new_models, list(new_set))
    }
  }

  uniq <- unique(lapply(new_models, paste, collapse = "|"))
  new_models <- lapply(uniq, function(s) strsplit(s, "\\|")[[1]])

  if (length(new_models) > m) {
    new_models <- new_models[1:m]
  }

  tibble(vars = new_models)
}

#------------------------------------------------------------
# 4. run_rashomon()
#------------------------------------------------------------
run_rashomon <- function(X, y, pmax = 5, m = 90, alpha = 0.5) {
  vars <- colnames(X)
  M <- list()

  # ----- k = 1 -----
  M[[1]] <- fit_models_dim(X, y, k = 1, m = m) %>%
    select_best(alpha = alpha)

  # ----- k = 2..pmax -----
  for (k in 2:pmax) {
    grown <- grow_from(M[[k - 1]], vars, k_next = k, m = m)

    models_k <- map_df(grown$vars, function(vs) {
      df <- data.frame(y = y, X[, vs, drop = FALSE])
      fit <- glm(y ~ ., data = df, family = binomial())

      tibble(
        vars  = list(vs),
        aic   = AIC(fit),
        coef  = list(coef(fit)),
        pvals = list(summary(fit)$coefficients[,4])
      )
    })

    M[[k]] <- select_best(models_k, alpha = alpha)
  }

  # ----- Summary tables -----
  predictor_counts <- map_df(seq_along(M), function(k) {
    tibble(
      dimension = k,
      predictor = unlist(M[[k]]$vars)
    )
  }) %>%
    count(dimension, predictor, name = "count")

  aic_summary <- map_df(seq_along(M), function(k) {
    tibble(
      dimension = k,
      aic = M[[k]]$aic
    )
  })

  return(list(
    M = M,
    predictor_counts = predictor_counts,
    aic_summary = aic_summary
  ))
}

```

```{r}
# Load cleaned dataset
adult <- read.csv("adult.csv", sep = ";", stringsAsFactors = FALSE)

# Use sex as binary response
y <- ifelse(adult$sex == "Male", 1, 0)

# Select 5 numeric predictors for Rashomon search
X <- adult[, c("age",
               "education.num",
               "capital.gain",
               "capital.loss",
               "hours.per.week")]
```

```{r, warning=FALSE}
# Example: using first 5 predictors to keep runtime small
X_sub <- X[, 1:5]
y_sub <- y

res <- run_rashomon(X_sub, y_sub, pmax = 3, m = 20, alpha = 0.5)

```

```{r, echo=FALSE}
res$M
```

```{r}
ggplot(res$predictor_counts,
       aes(x = predictor, y = count, fill = factor(dimension))) +
  geom_col(position = "dodge") +
  labs(
    title = "Predictor Inclusion Counts by Model Dimension",
    x = "Predictor",
    y = "Count",
    fill = "Dimension"
  ) +
  theme_minimal()
```

```{r}
ggplot(res$aic_summary, aes(x = factor(dimension), y = aic)) +
  geom_boxplot() +
  labs(
    title = "AIC Distribution by Model Dimension",
    x = "Model Dimension (k)",
    y = "AIC"
  ) +
  theme_minimal()
```
